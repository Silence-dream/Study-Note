## js 数据类型

### 基本数据类型

Number，String，Boolean，null，undefined，symbol，bigint

### 引用数据类型

object 和 function

object : 普通对象,数组对象,正则对象,日期对象,Math 数学函数对象

两种数据存储方式：

基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。

两种数据类型的区别：

- 堆比栈空间大，栈比堆运行速度快。

- 堆内存是无序存储，可以根据引用直接获取。

- 基础数据类型比较稳定，而且相对来说占用的内存小。

- 引用数据类型大小是动态的，而且是无限的。

## Object.assisn 的理解

```js
let obj1 = { name: "张飒" };
let obj2 = { name: "李四", age: 90 };
let result = Object.assign(obj1, obj2);
// Object.assign(target,source)
// 如果有同名的 key source 会覆盖 target
// 返回的结果会修改 target内的值

console.log(result); // { name: '李四', age: 90 }
result.name = "芜湖!";

console.log(obj1); // { name: '芜湖!', age: 90 }
```

## constructor 的理解

创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。

## map 和 forEach 的区别

相同点：

- 都是循环遍历数组中的每一项

- 每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）

- 匿名函数中的 this 都是指向 window

- 只能遍历数组

不同点：

- map()会分配内存空间存储新数组并返回，forEach()不会返回数据。

- forEach()允许 callback 更改原始数组的元素。map()返回新的数组。

## for of 可以遍历哪些对象

for..of..: 它是 es6 新增的一个遍历方法，但只限于迭代器(iterator), 所以普通的对象用 for..of 遍历
是会报错的。

可迭代的对象：包括 Array, Map, Set, String, TypedArray, arguments 对象等等

## indexof

```js
let str = "123";
let arr = [4, 5, 6];

// 返回对应值的下标  第二个参数是从哪里开始找,默认 0
console.log(str.indexOf(2));
console.log(arr.indexOf(5));
```

## iframe 有什么优点、缺点

优点：

1. iframe 能够原封不动的把嵌入的网页展现出来。
2. 如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
3. 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。
4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。

缺点：

1. iframe 会阻塞主页面的 onload 事件；
2. iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。
3. iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。
5. 很多的移动设备无法完全显示框架，设备兼容性差。
6. iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。

## instanceOf 原理 手动实现 function isInstanceOf (child, Parent)

```js
function Person() {}

let p = new Person();
// instanceof 用于判断实例是否属于某种类型
console.log(p instanceof Person);

// 遍历左边隐式 proto 即可
function new_instance_of(leftVaule, rightVaule) {
  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
  while (true) {
    if (leftVaule === null) {
      return false;
    }
    if (leftVaule === rightProto) {
      return true;
    }
    leftVaule = leftVaule.__proto__;
  }
}

console.log(new_instance_of(p, Array));
```

## 数组去重

### 1. 利用 ES6 Set 去重（ES6 中最常用）

### 2.利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）

### 3.利用 indexOf 去重

### 4.利用 sort()

### 5.利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）

### 6.利用 includes

### 7.利用 hasOwnProperty

### 8.利用 filter

### 9.利用递归去重

### 10.利用 Map 数据结构去重

### 11.利用 reduce+includes

### 12.[...new Set(arr)]

## null 和 undefined 的区别，如何让一个属性变为 null

undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。

null 作为一个基本数据类型为什么会被 typeof 运算符识别为 object 类型呢？
这是因为 javascript 中不同对象在底层都表示为二进制，而 javascript
中会把二进制前三位都为 0 的判断为 object 类型，而 null 的二进制表示全都是 0，自然前三位也是 0，所以执行 typeof 时会返回'object。
----引用自《你不知道的 javascript（上卷）》

## 数组和伪数组的区别

数组是一个特殊对象,与常规对象的区别：

- 当由新元素添加到列表中时，自动更新 length 属性
- 设置 length 属性，可以截断数组
- 从 Array.protoype 中继承了方法
- 属性为'Array'

### 类数组转换为数组

转换方法

- 使用 Array.from()
- 使用 Array.prototype.slice.call()
- 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组

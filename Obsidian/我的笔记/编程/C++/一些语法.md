## 文件的导入和导出

在 JavaScript 我们使用 import 和 export 导入和导出文件而在 C++ 中我们使用头文件(*.h)和源码文件(*.cpp)

例如在同级目录下定义一个`test.h`

```h
#include <iostream>

void sayHello() {
    std::cout << "Hello, World!" << std::endl;
}
```

同时创建一个 `index.cpp` 调用头文件的内容

```cpp
#include <iostream>

void sayHello() {
    std::cout << "Hello, World!" << std::endl;
}
```

此时你会疑问为什么引入标准库头文件不用写 `.h` 因为C++标准库里面的文件不需要写,编译器已经处理好了。

注意引入标准库头文件使用尖括号引入，编译器会优先从标准库中搜索，如果没有找到则会从当前目录搜索。与相反的则是使用引号引入头文件，在当前目录搜索，如果没有找到则会从标准库中搜索。



## 预处理指令 #pragma once

#pragma once。这个指令告诉预处理器这个文件只会被处理一次。这并不是标准 C++ 的一部分，但是所有主流的编译器都支持这个指令。如果你的编译器不支持这个指令，你可以使用传统的 #ifndef 指令来代替。

例如一份文件

A 依赖 B 和 C 的头文件

B 依赖 C 的头文件

使用 #include 语句会被替换成被包含的文件的内容，如果不处理的话,最终 A 会包含两份 C 的内容.

如果 C.h 中包含#pragma once这个预处理器指令，则在预处理器处理 A.h 的头文件时，则只会包含一次 C.h 的内容，不会因为 B.h 也包含 C.h 的引用就会在 A.h 中创建两份 C.h 的内容

```cpp
#ifndef _FileA
#define _FileA
// code
#endif

```


## 应用程序内存布局
一个应用程序在操作系统中运行时，它占用的内存一般分为以下几个区域。

内核空间：用于存储操作系统和驱动程序为进程提供的临时机器指令和中间变量。
映射段：用于装载或映射动态链接库，也常用于将文件内容映射到内存中。
代码段：用于存放应用程序的机器指令，为了防止指令被其他程序修改，代码段是只读的。
数据段：用于存储全局变量、静态变量（static）和常量数据（const）。
堆：用于存储应用程序运行过程中申请的内存空间，比如使用 malloc 方法或 new 关键字申请的内存。
栈：用于存储函数的局部变量、参数、返回值及调用者的上下文信息。

![ProcessMemory.png](https://cdn.jsdelivr.net/gh/Silence-dream/bed@master/img/202307201640971.awebp)

一个进程真正的内存使用情况并不像上图中描述的这样规整，每个区块的大小差异巨大，而且不同类别的内存可能会交叉出现，不同的内存区间也可能是不连续的、碎片化的。你应该关注数据段、堆和栈这三个内存区域，后文中我们还会反复提到这些概念。

JavaScript 的解释引擎 V8 也遵循这个内存布局约定，但 JavaScript 并不遵循这个约定，因为 JavaScript 是运行在 V8 之上的，由 V8 定义 JavaScript 的内存布局模型。

## 栈与栈帧



在`栈`空间中分配内存的变量不需要程序员手动销毁，`栈帧`销毁时`栈帧`上的变量会被自动销毁。

栈的总内存大小是固定的，而且非常小，在 Windows 操作系统中默认大小为 1M，当在栈空间中申请的内存超过栈的剩余空间时，将提示内存溢出错误。这也是为什么开发者要关注递归调用引发栈溢出的原因（递归调用会创建非常多的栈帧）。

## 堆

如果想让某个变量在函数调用结束之后仍然可用，那么可以在`堆`空间中为变量分配内存，使用 new 操作符就可以完成这项工作，new 操作符返回堆空间的地址（就是指针）。除非专门的设置（后文会讲：智能指针），开发者必须自己完成堆内存的释放工作，使用 delete 关键字可以完成这项工作（C++ 中的 delete 关键字与 JavaScript 中的 delete 关键字差异巨大）。

堆内存的大小与计算机系统中有效虚拟内存大小有关，比栈空间要大得多，大部分时候开发者都会**把大对象或数组放到堆中**。

堆内存没有专门的优化，使用效率较低，且容易产生内存碎片。





## 静态变量

​	






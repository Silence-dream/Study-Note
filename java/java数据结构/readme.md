---
title : java数据结构与算法
date : 2021-4-29
---

:::tip

Algorithm + Data Structures = Programs

  ( 算 法 +  数 据 结 构  = 程 序 ）

:::

## 什么是数据结构

- 数据结构(data structure)
  - 问题的数学模型，它反映数据及其之间关系。（存储结构和逻辑结构）
- 算  法
  - 处理问题的策略（是对数据运算的描述，是程序的逻辑抽象）
- 程  序
  - 为计算机处理问题而编制的一组指令集



![image-20210419203422070](https://gitee.com/qianshilei/test/raw/master/img/image-20210419203422070.png)





数据结构分为三大类

一、线性表：

线性表是为了解决单线存储而出现的。

数组：就是最简单粗暴的存储方法。就是直接拉出一大块数据存在那里。数组的快速存取其实只是一个副作用，因为所有的数据都在一起，可以直接算出来数据的地址。

链表：则是为了解决可以无线增长的需求的。因为找不到一大块可以连续的存入数据，甚至也不知道程序可能使用的数据总量，所以就没办法划分一块数据来使用，划小了不够用，划大了浪费（这在早年是非常大的事情）。所以必须想办法解决问题。最后采用的方法就是从入口开始，**每一个数据块不仅仅有数据，还会有指向下一个数据块的线索，用来寻找下一个数据。**这就是链表。

所谓的双向链表，只是加了一个向前的线索的链表而已。不仅如此，队列，栈，都是线性表的特殊形态。进行了操作上的限制罢了。既可以是数组，也可以是链表。

二、树：

树是为了解决单一入口下的非线性关联性的数据存储或者排序这样的功能而来的。

最常见的应用是编程时候的map，就是利用了二叉树的可排序和可以快速插入并且保持序列完整的特性来构建键值数据对，来实现数据的插入增加以及快速查找的能力的。

还有做语法解析，文字处理等等很多场景也会用到树。这就不一一赘述了。当然在吃透线性表的基础上，再去理解树也并不难。因为在本质上，树相对于链表，就是**每个节点不止有一个后续节点但是只有一个前置节点。**

三 图：

图是数据结构里最难的一部分，但是很多学校并不作为重点，因为确实大部分人不会用到。

图的本质其实就是把线性表进一步扩展，**每个节点会有不止一个前置和后缀节点，而且前置和后缀的概念也不再明晰，变成了关联节点**。



作者：赛博铁犁
链接：https://www.zhihu.com/question/21318658/answer/154739001
来源：知乎

## 线性表

### 线性表的基本概念

所谓的线性表，就是将数据排成像一条长线一样的结构，数组，链表，栈，队列都 是线性表结构，线性表上的数据最多只有前后两个方向，下面以一幅图的形式来展现一下线性表结构



![image-20210506082926833](img/image-20210506082926833.png)



非线性数据结构：树、图等

![image-20210506093548271](img/image-20210506093548271.png)



#### 线性表的特点

1. 它由n个同类型的元素组成；

2. 每个元素除第一个元素和最后一个元素之外,有且仅有一个前驱和一个后继；

3. 其长度可以动态的增长或减少

4. 可以对线性表中任何数据元素进行访问

5. 数据元素的插入和删除操作可以在线性表中的任何位置进行

6. 可以求线性表中指定元素的前驱和后继。

:::tip

前驱的话就是前面一个元素,后继就是后面一个元素

:::

#### 线性表存储结构

- 顺序存储结构：使用数组
  - 顺序存储结构表示的线性表称为顺序表
- 线性表的线性存储结构：物理空间上采用连续的区域存储
  
- 链式存储结构：链表
  - 链式存储结构表示的线性表称为链表，链表又分为单链表、双向链表、循环链表

### 线性表的基本操作

1. 线性表的置空操作：clear()

2. 线性表判空操作：isEmpty()

3. 求线性表元素的个数：length()、getSize()

4. 求线性表的容量：getCapacity()

5. 取元素操作：get(i)

6. 插入操作：insert(i,x)

7. 删除操作：remove(i)

8. 查找操作：indexOf(i)

9. 输出操作：toString()

```java

```

## 时间复杂度

- 抛开算法运行的软硬件环境，只考虑算法与问题规模之间的关系。

- 算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。

- 算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。

- 一般使用O 表示时间复杂度，O(1)、O(n)、O(n^2)、O(n^3)、O(log2n)

```
T = 2*n + 2                          O(n)
T = 2000*n + 10000            		 O(n)
T = 1*n*n  + 0                       O(n^2)
T = 2*n*n + 300*n + 10     			 O(N^2)
```

### 分析动态数组的时间复杂度

```
addLast(e)		O(1)
add First(e)	O(n)
add (index, e)	O(n/2)=0(n)

removeLast(e)	O(1)
remove First(e)	O(n)
remove(index,e) O(n/2)=o(n)

set(index, e) O(1)

get(index)	O(1)
contains(e) O(n)
find(e)		O(n)
```

### 时间复杂度分析

- O(1)的时间复杂度只能代表算法的执行，不受任何变量的影响，他的复杂度是常量级别的

```java
public void show(){   
    sout("name");    
    sout("age");    
    sout("sex"); 
}
```

- O(n):算法的执行效率跟n的大小呈线性关系

```java
public  void  sum(int[]  arr1){ 
    int  sum  =  0;
	for(int  i=0;i<arr1.length;i++){ 
        sum  +=  arr1[i];
	}
	sout(sum);
}//O(n)

public  void  sum(int[]  arr1,int[]  arr2){ 
    int  sum  =  0;
	for(int  i=0;i<arr1.length;i++){ 
        sum  +=  arr1[i];
	}
	sout(sum);

	int  sum2  =  0;
	for(int  j=0;j<arr1.length;j++){ 
        sum  +=  arr1[j];
	}
	sout(sum);
```

- ![img](img/clip_image001.gif)O(n^2)：嵌套for循环

### 空间复杂度分析

- O(1)

```java
void  print(int  n)  { 
    int  i  =  0;
	int[]  a  =  {1,2,3,34,5,6,7};
	for  (i;  i  <n;  ++i)  { 
        a[i]  =  i  *  i;
	for  (i  =  n-1;  i  >=  0;  --i) 					System.out.println(a[i]);
}

```

- O(n)

```java
void  print(int  n)  { 
    int  i  =  0;
	int[]  a  =  new  int[n]; 
    for  (i;  i  <n;  ++i)  {
		a[i]  =  i  *  i;
	for  (i  =  n-1;  i  >=  0;  --i) 					System.out.println(a[i]);
}
```

- O(n^2)

```java
void  print(int  n)  { 
    int  i  =  0;
	int  z  =  0;
	int[]  a  =  new  int[n]; 
    for  (i;  i  <n;  ++i)  {
		for  (j  =  n-1;  j  >=  0;  --j){ 
       	 z = i * j; System.out.println(z);
		}
	}
}
```

